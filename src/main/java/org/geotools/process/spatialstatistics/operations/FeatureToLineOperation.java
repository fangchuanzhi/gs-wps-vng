/*
 *    GeoTools - The Open Source Java GIS Toolkit
 *    http://geotools.org
 *
 *    (C) 2014, Open Source Geospatial Foundation (OSGeo)
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation;
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 */
package org.geotools.process.spatialstatistics.operations;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.logging.Logger;

import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.process.spatialstatistics.core.FeatureTypes;
import org.geotools.process.spatialstatistics.core.FeatureTypes.SimpleShapeType;
import org.geotools.process.spatialstatistics.storage.IFeatureInserter;
import org.geotools.util.logging.Logging;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryComponentFilter;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.LineString;
import com.vividsolutions.jts.geom.MultiPoint;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.geom.prep.PreparedGeometry;
import com.vividsolutions.jts.geom.prep.PreparedGeometryFactory;
import com.vividsolutions.jts.index.strtree.STRtree;
import com.vividsolutions.jts.linearref.LinearLocation;
import com.vividsolutions.jts.linearref.LocationIndexedLine;
import com.vividsolutions.jts.operation.linemerge.LineMerger;

/**
 * Creates a features containing lines generated by converting polygon boundaries to lines, or splitting line, polygon, or both features at their
 * intersections.
 * 
 * @author Minpa Lee, MangoSystem
 * 
 * @source $URL$
 * 
 */
public class FeatureToLineOperation extends GeneralOperation {
    protected static final Logger LOGGER = Logging.getLogger(FeatureToLineOperation.class);

    private STRtree spatialIndex;

    private boolean preserveAttributes = true;

    private boolean isPolygon = false;

    public FeatureToLineOperation() {

    }

    public SimpleFeatureCollection execute(SimpleFeatureCollection inputFeatures,
            boolean preserveAttributes) throws IOException {
        this.preserveAttributes = preserveAttributes;
        this.isPolygon = FeatureTypes.getSimpleShapeType(inputFeatures) == SimpleShapeType.POLYGON;

        buildSpatialIndex(inputFeatures);

        // prepare transactional feature store
        SimpleFeatureType schema = inputFeatures.getSchema();
        SimpleFeatureType featureType = FeatureTypes.build(schema, LineString.class);
        if (!preserveAttributes) {
            CoordinateReferenceSystem crs = schema.getCoordinateReferenceSystem();
            featureType = FeatureTypes.getDefaultType(schema.getTypeName(), LineString.class, crs);
        }

        IFeatureInserter featureWriter = getFeatureWriter(featureType);
        SimpleFeatureIterator featureIter = inputFeatures.features();
        try {
            List<LineString> neighbors = new ArrayList<LineString>();
            while (featureIter.hasNext()) {
                SimpleFeature feature = featureIter.next();
                String id = feature.getID();
                Geometry multi = (Geometry) feature.getDefaultGeometry();
                if (isPolygon) {
                    multi = multi.getBoundary();
                }

                for (int index = 0; index < multi.getNumGeometries(); index++) {
                    LineString source = (LineString) multi.getGeometryN(index);
                    PreparedGeometry prepared = PreparedGeometryFactory.prepare(source);
                    neighbors.clear();

                    // query
                    for (@SuppressWarnings("unchecked")
                    Iterator<NearFeature> iter = (Iterator<NearFeature>) spatialIndex.query(
                            source.getEnvelopeInternal()).iterator(); iter.hasNext();) {
                        NearFeature sample = iter.next();
                        if (sample.id.equals(id) || prepared.disjoint(sample.location)) {
                            continue;
                        }
                        neighbors.add(sample.location);
                    }

                    if (neighbors.size() == 0) {
                        insertFeature(featureWriter, feature, source);
                        continue;
                    }

                    // build intersection points
                    List<Coordinate> intersections = processGeometry(source, neighbors);
                    if (intersections.size() > 0) {
                        List<Geometry> splits = splitLines(source, intersections);
                        for (Geometry lineString : splits) {
                            if (lineString == null || lineString.getLength() == 0) {
                                continue;
                            }

                            insertFeature(featureWriter, feature, lineString);
                        }
                    } else {
                        insertFeature(featureWriter, feature, source);
                    }
                }
            }
        } catch (IOException e) {
            featureWriter.rollback(e);
        } finally {
            featureWriter.close(featureIter);
        }

        return featureWriter.getFeatureCollection();
    }

    private void insertFeature(IFeatureInserter featureWriter, SimpleFeature source,
            Geometry newGeometry) throws IOException {
        SimpleFeature newFeature = featureWriter.buildFeature();
        if (preserveAttributes) {
            featureWriter.copyAttributes(source, newFeature, false);
        }
        newFeature.setDefaultGeometry(newGeometry);
        featureWriter.write(newFeature);
    }

    private List<Coordinate> processGeometry(LineString source, List<LineString> neighbors) {
        final List<Point> points = new ArrayList<Point>();
        final List<LineString> lines = new ArrayList<LineString>();

        // intersection
        for (LineString neighbor : neighbors) {
            lines.clear();
            Geometry intersections = source.intersection(neighbor);

            // first, extract points
            intersections.apply(new GeometryComponentFilter() {
                @Override
                public void filter(Geometry geom) {
                    if (geom instanceof Point) {
                        points.add((Point) geom);
                    } else if (geom instanceof MultiPoint) {
                        for (int index = 0; index < geom.getNumGeometries(); index++) {
                            points.add((Point) geom.getGeometryN(index));
                        }
                    }
                }
            });

            // second, extract line
            LineMerger lineMerger = new LineMerger();
            lineMerger.add(intersections);

            @SuppressWarnings("rawtypes")
            Collection collection = lineMerger.getMergedLineStrings();

            @SuppressWarnings("rawtypes")
            Iterator iter = collection.iterator();
            while (iter.hasNext()) {
                lines.add((LineString) iter.next());
            }

            // extract node
            if (lines.size() > 0) {
                for (LineString line : lines) {
                    points.add(line.getStartPoint());
                    points.add(line.getEndPoint());
                }
            }
        }

        Geometry multi = source.getFactory().createMultiPoint(GeometryFactory.toPointArray(points));
        return Arrays.asList(multi.union().getCoordinates());
    }

    private List<Geometry> splitLines(Geometry line, List<Coordinate> coordinates) {
        List<Geometry> splits = new ArrayList<Geometry>();
        boolean needMerge = isPolygon && coordinates.contains(line.getCoordinate()) == false;

        LocationIndexedLine liLine = new LocationIndexedLine(line);

        // sort point along line
        SortedMap<Double, LinearLocation> sortedMap = new TreeMap<Double, LinearLocation>();
        for (Coordinate coordinate : coordinates) {
            LinearLocation location = liLine.indexOf(coordinate);
            int segIndex = location.getSegmentIndex();
            double segFraction = location.getSegmentFraction();
            sortedMap.put(Double.valueOf(segIndex + segFraction), location);
        }

        // split
        LinearLocation startIndex = liLine.getStartIndex();
        for (Entry<Double, LinearLocation> entrySet : sortedMap.entrySet()) {
            LinearLocation endIndex = entrySet.getValue();
            LineString left = (LineString) liLine.extractLine(startIndex, endIndex);
            if (left != null && !left.isEmpty() && left.getLength() > 0) {
                left.setUserData(entrySet.getValue());
                splits.add(left);
            }
            startIndex = endIndex;
        }

        // add last segment
        Geometry left = liLine.extractLine(startIndex, liLine.getEndIndex());
        if (left != null && !left.isEmpty() && left.getLength() > 0) {
            splits.add(left);
        }

        if (needMerge && splits.size() > 1) {
            LineMerger lineMerger = new LineMerger();
            lineMerger.add(splits.get(0));
            lineMerger.add(splits.get(splits.size() - 1));

            @SuppressWarnings("rawtypes")
            Collection collection = lineMerger.getMergedLineStrings();
            Geometry merged = (Geometry) collection.iterator().next();

            splits.remove(0);
            splits.remove(splits.size() - 1);
            splits.add(merged);
        }

        return splits;
    }

    private void buildSpatialIndex(SimpleFeatureCollection features) {
        spatialIndex = new STRtree();
        SimpleFeatureIterator featureIter = features.features();
        try {
            while (featureIter.hasNext()) {
                SimpleFeature feature = featureIter.next();
                Geometry geometry = (Geometry) feature.getDefaultGeometry();
                if (isPolygon) {
                    geometry = geometry.getBoundary();
                }

                for (int index = 0; index < geometry.getNumGeometries(); index++) {
                    LineString part = (LineString) geometry.getGeometryN(index);
                    NearFeature nearFeature = new NearFeature(part, feature.getID());
                    spatialIndex.insert(part.getEnvelopeInternal(), nearFeature);
                }
            }
        } finally {
            featureIter.close();
        }
    }

    static final class NearFeature {

        public LineString location;

        public Object id;

        public NearFeature(LineString location, Object id) {
            this.location = location;
            this.id = id;
        }
    }
}